<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go on Hello</title><link>https://reggieteng.github.io/tags/go/</link><description>Recent content in go on Hello</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Tue, 20 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://reggieteng.github.io/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>golang标准包--strconv</title><link>https://reggieteng.github.io/posts/2021/04/golang%E6%A0%87%E5%87%86%E5%8C%85-strconv/</link><pubDate>Tue, 20 Apr 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/04/golang%E6%A0%87%E5%87%86%E5%8C%85-strconv/</guid><description>简介 strconv包实现了基本数据类型和其字符串表示的相互转换，常用于string转int
字符串转换为整型之间的转换 字符串转换为整型 包括三个函数：ParseInt()、ParseUint() 和 Atoi().其中Atoi()是ParseInt()的便捷版，内部通过调用ParseInt(s, 10, 0)来实现的; ParseInt 转为有符号整型；ParseUint 转为无符号整型，
// 参数 s 代表待转换的字符串 // 参数 base 代表字符串按照给定的进制进行解释 // 参数 bitSize 表示的是整数取值范围,或者说整数的具体类型。取值 0、8、16、32 和 64 分别代表 int、int8、int16、int32 和 int64。 func ParseInt(s string, base int, bitSize int) (i int64, err error) func ParseUint(s string, base int, bitSize int) (n uint64, err error) func Atoi(s string) (i int, err error) n, err := strconv.ParseInt(&amp;#34;128&amp;#34;, 10, 8) 注意:
如上转换ParseInt/ParseUint实现时,如果字符串表示的整数超过了bitSize参数能够表示的范围,则会返回ErrRange,同时会返回bitSize能够表示的最大或最小值.因此,这里的n是 127. ParseInt()返回的是int64,这是为了能够容纳所有的整型,在实际使用中,可以根据传递的 bitSize,然后将结果转为实际需要的类型.</description></item><item><title>golang/x包--ssh</title><link>https://reggieteng.github.io/posts/2021/04/golang/x%E5%8C%85-ssh/</link><pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/04/golang/x%E5%8C%85-ssh/</guid><description>简介 在相对较小的项目中我们的服务器很少，此时我们会直接使用ssh登录服务器对服务器进行管理。当服务器增多/服务器更换后，对服务器的管理就会变得很麻烦和低效。此时我们必须要实现服务器管理的自动化。
远程命令执行 golang.org/x/crypto/ssh包就是golang中对ssh协议的实现。 我们分四步进行:
1 创建ssh登陆配置(ssh.ClientConfig) 2 dial 获取ssh client 3 创建ssh-session 4 执行远程命令 1.创建ssh.ClientConfig 源码中ssh.ClientConfig 结构体如下
type ClientConfig struct { // Config contains configuration that is shared between clients and // servers. Config // User contains the username to authenticate as. User string // Auth contains possible authentication methods to use with the // server. Only the first instance of a particular RFC 4252 method will // be used during authentication.</description></item><item><title>golang标准包--flag</title><link>https://reggieteng.github.io/posts/2021/04/golang%E6%A0%87%E5%87%86%E5%8C%85-flag/</link><pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/04/golang%E6%A0%87%E5%87%86%E5%8C%85-flag/</guid><description>简介 flag包是golang标准包之一.它实现了命令行参数的解析.flag包使得开发命令行工具更为简单.
基本流程 使用flag包基本流程分为三步
1 定义需要解析的命令行参数 2 调用flag.Parse() 3 根据后续的逻辑处理解析后的flag参数 1.定义命令行参数 // option 1 // string的注册,其中&amp;#34;l&amp;#34;为调用时的name &amp;#34;warn&amp;#34;为默认值 &amp;#34;log level&amp;#34;可理解为说明 FlagLogLevel = flag.String(&amp;#34;l&amp;#34;, &amp;#34;warn&amp;#34;, &amp;#34;log level&amp;#34;) // int的注册 FlagThreads = flag.Int(&amp;#34;t&amp;#34;, 3, &amp;#34;threads used when starting&amp;#34;) // bool的注册 FlagVersion = flag.Bool(&amp;#34;v&amp;#34;, false, &amp;#34;show version&amp;#34;) // option 2 // flag.XxxVar()，将 flag 绑定到一个变量上 var flagLogLevel string var flagThreads int var flagVersion bool flag.StringVar(&amp;amp;flagLogLevel, &amp;#34;l&amp;#34;, &amp;#34;warn&amp;#34;, &amp;#34;log level&amp;#34;) flag.IntVar(&amp;amp;flagThreads, &amp;#34;t&amp;#34;, 1234, &amp;#34;threads used when starting&amp;#34;) flag.</description></item><item><title>gin分模块注册router</title><link>https://reggieteng.github.io/posts/2021/03/gin%E5%88%86%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%86%8Crouter/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/03/gin%E5%88%86%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%86%8Crouter/</guid><description>最基本的路由注册
下面是最基本的router注册方式,只适用于小型项目或学习demo
package main import ( &amp;#34;net/http&amp;#34; &amp;#34;github.com/gin-gonic/gin&amp;#34; ) func helloHandler(c *gin.Context) { c.JSON(http.StatusOK, gin.JSON{ &amp;#34;message&amp;#34;: &amp;#34;Hello world!&amp;#34;, }) } func main() { r := gin.Default() r.GET(&amp;#34;/hello&amp;#34;, helloHandler) if err := r.Run(); err != nil { fmt.Println(&amp;#34;launch service failed, err:%v\n&amp;#34;, err) } } router注册拆出
当项目的规模逐渐变大时,在main,go中定义router非常不合适.此时就可以考虑将router部分代码单独写出。此时文件结构为
. ├── ... --- 其他文件 ├── main.go --- 项目入口 └── router.go --- router文件 其中router.go代码如下
package main import ( &amp;#34;net/http&amp;#34; &amp;#34;github.com/gin-gonic/gin&amp;#34; ) func helloHandler(c *gin.</description></item></channel></rss>