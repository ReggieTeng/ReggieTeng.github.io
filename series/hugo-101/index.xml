<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hugo 101 on Hello</title><link>https://reggieteng.github.io/series/hugo-101/</link><description>Recent content in Hugo 101 on Hello</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Tue, 31 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://reggieteng.github.io/series/hugo-101/index.xml" rel="self" type="application/rss+xml"/><item><title>drone的yml文件详解</title><link>https://reggieteng.github.io/posts/2021/08/drone%E7%9A%84yml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</link><pubDate>Tue, 31 Aug 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/08/drone%E7%9A%84yml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</guid><description>cicd简介 CI全称为Continuous Integration，意为持续集成，是在源代码变更后自动检测、拉取、构建和进行自动化测试的过程，属于开发人员的自动化流程。该解决方案可以解决在一次开发中有太多应用分支，从而导致相互冲突的问题。其基本思路是，自动化监测代码仓库的变化并拉取最新代码、编译构建和自动化测试。CI的触发方式可分为以下三种：
轮询：按一定的时间间隔反复询问代码仓库是否发生了变更，若发生了变更则开启CI流程 定时：定期从代码仓库拉去最新代码并进行构建与测试，不必关心是否有变更发生 推送：当代码仓库发生变更时，通过推送的方式(如webhook)通知CI进行任务，这需要CI环境被代码仓库访问到，因此需要一个外网可达地址 CD指的是持续交付(Continuous Delivery)或持续部署(Continuous Deployment)。持续交付通常是指开发人员对应用的更改会自动进行错误测试并上传到存储库（如 GitHub 或容器注册表），然后由运维团队将其部署到实时生产环境中。持续部署指的是自动将开发人员的更改从存储库发布到生产环境，它以持续交付为基础，实现了管道后续阶段的自动化。 CI/CD 既可能仅指持续集成和持续交付构成的关联环节，也可以指持续集成、持续交付和持续部署这三项构成的关联环节。
Drone 基于Docker的 CI/CD 工具Drone所有编译、测试的流程都在Docker容器中进行。 开发者只需在项目中包含.drone.yml文件，将代码推送到git仓库，Drone就能够自动化的进行编译、测试、发布。 示例yml文件如下：
--- kind: pipeline type: docker name: default # 指定代码空间，git代码会被clone到指定的path workspace: path: /drone/src # 指定编译平台 platform: os: linux arch: amd64 clone: disable: true volumes: - name: godeps path: /go/pkg steps: - name: 测试环境代码clone # 失败退出 failure: always image: golang:1.15 commands: - git init - git fetch http://xxx.git dev - git checkout FETCH_HEAD - git rev-parse HEAD when: branch: - dev event: - push - name: 线上环境代码clone failure: always image: golang:1.</description></item><item><title>nginx配置文件</title><link>https://reggieteng.github.io/posts/2021/08/nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link><pubDate>Tue, 03 Aug 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/08/nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid><description>nginx的主配置文件是nginx.conf，这个配置文件一共由三部分组成，分别为全局块、events块和http块。在http块中，又包含http全局块、多个server块。每个server块中，可以包含server全局块和多个location块。在同一配置块中嵌套的配置块，各个之间不存在次序关系。下面就是一个nginx.conf
#全局块 #user nobody; worker_processes 1; #event块 events { worker_connections 1024; } #http块 http { #http全局块 include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; #server块 server { #server全局块 listen 8000; server_name localhost; #location块 location / { root html; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } #这边可以有多个server块 server { ... } } 一、全局块 主要设置一些影响Nginx服务器整体运行的配置指令，因此，这些指令的作用域是Nginx服务器全局。
# 指定可以运行nginx服务的用户和用户组，只能在全局块配置 # user [user] [group] # 将user指令注释掉，或者配置成nobody的话所有用户都可以运行 # user nobody nobody; # 指定工作线程数，可以制定具体的进程数，也可使用自动模式，这个指令只能在全局块配置 # worker_processes number | auto； # 举例：指定4个工作线程，这种情况下会生成一个master进程和4个worker进程 # worker_processes 4; 二、events块 events块涉及的指令主要影响Nginx服务器与用户的网络连接。常用到的设置包括是否开启对多worker process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型处理连接请求，每个worker process可以同时支持的最大连接数等。</description></item><item><title>sqlx--golang操作数据库的第三方包</title><link>https://reggieteng.github.io/posts/2021/05/sqlx-golang%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85/</link><pubDate>Fri, 14 May 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/05/sqlx-golang%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85/</guid><description>一、简介
sqlx是一个操作数据库的库,它在golang标准包database/sql之上增加了很多扩展，简化数据库操作代码的书写.配合sql driver可支持mysql、postgresql.
sqlx设计和database/sql使用方法是一样的.包含有4中主要的handle types:
sqlx.DB - 和sql.DB相似，表示数据库. sqlx.Tx - 和sql.Tx相似，表示transacion。 sqlx.Stmt - 和sql.Stmt相似，表示prepared statement. sqlx.NamedStmt - 表示prepared statement（支持named parameters） 所有的handler types都提供了对database/sql的兼容，意味着当你调用sql.DB.Query时,可以直接替换为sqlx.DB.Query.这就使得sqlx可以很容易的加入到已有的数据库项目中.
此外，sqlx还有两个cursor类型:
sqlx.Rows - 和sql.Rows类似，Queryx返回. sqlx.Row - 和sql.Row类似，QueryRowx返回. 二、使用
1.获取DB对象(sqlx.Open())
// Open is the same as sql.Open, but returns an *sqlx.DB instead. func Open(driverName, dataSourceName string) (*DB, error) { db, err := sql.Open(driverName, dataSourceName) if err != nil { return nil, err } return &amp;amp;DB{DB: db, driverName: driverName, Mapper: mapper()}, err } sqlx.</description></item><item><title>golang--strconv</title><link>https://reggieteng.github.io/posts/2021/04/golang-strconv/</link><pubDate>Tue, 20 Apr 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/04/golang-strconv/</guid><description>简介 strconv包实现了基本数据类型和其字符串表示的相互转换，常用于string转int
字符串转换为整型之间的转换 字符串转换为整型 包括三个函数：ParseInt()、ParseUint() 和 Atoi().其中Atoi()是ParseInt()的便捷版，内部通过调用ParseInt(s, 10, 0)来实现的; ParseInt 转为有符号整型；ParseUint 转为无符号整型，
// 参数 s 代表待转换的字符串 // 参数 base 代表字符串按照给定的进制进行解释 // 参数 bitSize 表示的是整数取值范围,或者说整数的具体类型。取值 0、8、16、32 和 64 分别代表 int、int8、int16、int32 和 int64。 func ParseInt(s string, base int, bitSize int) (i int64, err error) func ParseUint(s string, base int, bitSize int) (n uint64, err error) func Atoi(s string) (i int, err error) n, err := strconv.ParseInt(&amp;#34;128&amp;#34;, 10, 8) 注意:
如上转换ParseInt/ParseUint实现时,如果字符串表示的整数超过了bitSize参数能够表示的范围,则会返回ErrRange,同时会返回bitSize能够表示的最大或最小值.因此,这里的n是 127. ParseInt()返回的是int64,这是为了能够容纳所有的整型,在实际使用中,可以根据传递的 bitSize,然后将结果转为实际需要的类型.</description></item><item><title>golang/x包--ssh</title><link>https://reggieteng.github.io/posts/2021/04/golang/x%E5%8C%85-ssh/</link><pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/04/golang/x%E5%8C%85-ssh/</guid><description>简介 在相对较小的项目中我们的服务器很少，此时我们会直接使用ssh登录服务器对服务器进行管理。当服务器增多/服务器更换后，对服务器的管理就会变得很麻烦和低效。此时我们必须要实现服务器管理的自动化。
远程命令执行 golang.org/x/crypto/ssh包就是golang中对ssh协议的实现。 我们分四步进行:
1 创建ssh登陆配置(ssh.ClientConfig) 2 dial 获取ssh client 3 创建ssh-session 4 执行远程命令 1.创建ssh.ClientConfig 源码中ssh.ClientConfig 结构体如下
type ClientConfig struct { // Config contains configuration that is shared between clients and // servers. Config // User contains the username to authenticate as. User string // Auth contains possible authentication methods to use with the // server. Only the first instance of a particular RFC 4252 method will // be used during authentication.</description></item><item><title>golang--flag</title><link>https://reggieteng.github.io/posts/2021/04/golang-flag/</link><pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/04/golang-flag/</guid><description>简介 flag包是golang标准包之一.它实现了命令行参数的解析.flag包使得开发命令行工具更为简单.
基本流程 使用flag包基本流程分为三步
1 定义需要解析的命令行参数 2 调用flag.Parse() 3 根据后续的逻辑处理解析后的flag参数 1.定义命令行参数 // option 1 // string的注册,其中&amp;#34;l&amp;#34;为调用时的name &amp;#34;warn&amp;#34;为默认值 &amp;#34;log level&amp;#34;可理解为说明 FlagLogLevel = flag.String(&amp;#34;l&amp;#34;, &amp;#34;warn&amp;#34;, &amp;#34;log level&amp;#34;) // int的注册 FlagThreads = flag.Int(&amp;#34;t&amp;#34;, 3, &amp;#34;threads used when starting&amp;#34;) // bool的注册 FlagVersion = flag.Bool(&amp;#34;v&amp;#34;, false, &amp;#34;show version&amp;#34;) // option 2 // flag.XxxVar()，将 flag 绑定到一个变量上 var flagLogLevel string var flagThreads int var flagVersion bool flag.StringVar(&amp;amp;flagLogLevel, &amp;#34;l&amp;#34;, &amp;#34;warn&amp;#34;, &amp;#34;log level&amp;#34;) flag.IntVar(&amp;amp;flagThreads, &amp;#34;t&amp;#34;, 1234, &amp;#34;threads used when starting&amp;#34;) flag.</description></item><item><title>gin分模块注册router</title><link>https://reggieteng.github.io/posts/2021/03/gin%E5%88%86%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%86%8Crouter/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/03/gin%E5%88%86%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%86%8Crouter/</guid><description>最基本的路由注册
下面是最基本的router注册方式,只适用于小型项目或学习demo
package main import ( &amp;#34;net/http&amp;#34; &amp;#34;github.com/gin-gonic/gin&amp;#34; ) func helloHandler(c *gin.Context) { c.JSON(http.StatusOK, gin.JSON{ &amp;#34;message&amp;#34;: &amp;#34;Hello world!&amp;#34;, }) } func main() { r := gin.Default() r.GET(&amp;#34;/hello&amp;#34;, helloHandler) if err := r.Run(); err != nil { fmt.Println(&amp;#34;launch service failed, err:%v\n&amp;#34;, err) } } router注册拆出
当项目的规模逐渐变大时,在main,go中定义router非常不合适.此时就可以考虑将router部分代码单独写出。此时文件结构为
. ├── ... --- 其他文件 ├── main.go --- 项目入口 └── router.go --- router文件 其中router.go代码如下
package main import ( &amp;#34;net/http&amp;#34; &amp;#34;github.com/gin-gonic/gin&amp;#34; ) func helloHandler(c *gin.</description></item><item><title>Debian添加work用户</title><link>https://reggieteng.github.io/posts/2021/03/debian%E6%B7%BB%E5%8A%A0work%E7%94%A8%E6%88%B7/</link><pubDate>Thu, 11 Mar 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/03/debian%E6%B7%BB%E5%8A%A0work%E7%94%A8%E6%88%B7/</guid><description>一般在开发中很少使用root用户，可以创建work用户进行软件安装等操作。
以root用户登陆服务器后，添加work用户 useradd -d /home/work -s /bin/bash -m work
设置work用户的密码 passwd work
将work用户添加至sudo组中 adduser work sudo
注意:以上操作均在root用户下操作，若非root用户，则需要加sudo
关于useradd命令的参数意义如下，供参考：
-c&amp;lt;备注&amp;gt;：加上备注文字。备注文字会保存在passwd的备注栏位中；
-d&amp;lt;登入目录&amp;gt;：指定用户登入时的启始目录； -D：变更预设值；
-e&amp;lt;有效期限&amp;gt;：指定帐号的有效期限；
-f&amp;lt;缓冲天数&amp;gt;：指定在密码过期后多少天即关闭该帐号；
-g&amp;lt;群组&amp;gt;：指定用户所属的群组；
-G&amp;lt;群组&amp;gt;：指定用户所属的附加群组；
-m：自动建立用户的登入目录；
-M：不要自动建立用户的登入目录；
-n：取消建立以用户名称为名的群组；
-r：建立系统帐号；
-s：指定用户登入后所使用的shell；
-u：指定用户id。</description></item></channel></rss>