<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hugo 101 on Hello</title><link>https://reggieteng.github.io/series/hugo-101/</link><description>Recent content in Hugo 101 on Hello</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Fri, 14 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://reggieteng.github.io/series/hugo-101/index.xml" rel="self" type="application/rss+xml"/><item><title>sqlx--golang操作数据库的第三方包</title><link>https://reggieteng.github.io/posts/2021/05/sqlx-golang%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85/</link><pubDate>Fri, 14 May 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/05/sqlx-golang%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85/</guid><description>一、简介
sqlx是一个操作数据库的库,它在golang标准包database/sql之上增加了很多扩展，简化数据库操作代码的书写.配合sql driver可支持mysql、postgresql.
sqlx设计和database/sql使用方法是一样的.包含有4中主要的handle types:
sqlx.DB - 和sql.DB相似，表示数据库. sqlx.Tx - 和sql.Tx相似，表示transacion。 sqlx.Stmt - 和sql.Stmt相似，表示prepared statement. sqlx.NamedStmt - 表示prepared statement（支持named parameters） 所有的handler types都提供了对database/sql的兼容，意味着当你调用sql.DB.Query时,可以直接替换为sqlx.DB.Query.这就使得sqlx可以很容易的加入到已有的数据库项目中.
此外，sqlx还有两个cursor类型:
sqlx.Rows - 和sql.Rows类似，Queryx返回. sqlx.Row - 和sql.Row类似，QueryRowx返回. 二、使用
1.获取DB对象(sqlx.Open())
// Open is the same as sql.Open, but returns an *sqlx.DB instead. func Open(driverName, dataSourceName string) (*DB, error) { db, err := sql.Open(driverName, dataSourceName) if err != nil { return nil, err } return &amp;amp;DB{DB: db, driverName: driverName, Mapper: mapper()}, err } sqlx.</description></item><item><title>golang--strconv</title><link>https://reggieteng.github.io/posts/2021/04/golang-strconv/</link><pubDate>Tue, 20 Apr 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/04/golang-strconv/</guid><description>简介 strconv包实现了基本数据类型和其字符串表示的相互转换，常用于string转int
字符串转换为整型之间的转换 字符串转换为整型 包括三个函数：ParseInt()、ParseUint() 和 Atoi().其中Atoi()是ParseInt()的便捷版，内部通过调用ParseInt(s, 10, 0)来实现的; ParseInt 转为有符号整型；ParseUint 转为无符号整型，
// 参数 s 代表待转换的字符串 // 参数 base 代表字符串按照给定的进制进行解释 // 参数 bitSize 表示的是整数取值范围,或者说整数的具体类型。取值 0、8、16、32 和 64 分别代表 int、int8、int16、int32 和 int64。 func ParseInt(s string, base int, bitSize int) (i int64, err error) func ParseUint(s string, base int, bitSize int) (n uint64, err error) func Atoi(s string) (i int, err error) n, err := strconv.ParseInt(&amp;#34;128&amp;#34;, 10, 8) 注意:
如上转换ParseInt/ParseUint实现时,如果字符串表示的整数超过了bitSize参数能够表示的范围,则会返回ErrRange,同时会返回bitSize能够表示的最大或最小值.因此,这里的n是 127. ParseInt()返回的是int64,这是为了能够容纳所有的整型,在实际使用中,可以根据传递的 bitSize,然后将结果转为实际需要的类型.</description></item><item><title>golang/x包--ssh</title><link>https://reggieteng.github.io/posts/2021/04/golang/x%E5%8C%85-ssh/</link><pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/04/golang/x%E5%8C%85-ssh/</guid><description>简介 在相对较小的项目中我们的服务器很少，此时我们会直接使用ssh登录服务器对服务器进行管理。当服务器增多/服务器更换后，对服务器的管理就会变得很麻烦和低效。此时我们必须要实现服务器管理的自动化。
远程命令执行 golang.org/x/crypto/ssh包就是golang中对ssh协议的实现。 我们分四步进行:
1 创建ssh登陆配置(ssh.ClientConfig) 2 dial 获取ssh client 3 创建ssh-session 4 执行远程命令 1.创建ssh.ClientConfig 源码中ssh.ClientConfig 结构体如下
type ClientConfig struct { // Config contains configuration that is shared between clients and // servers. Config // User contains the username to authenticate as. User string // Auth contains possible authentication methods to use with the // server. Only the first instance of a particular RFC 4252 method will // be used during authentication.</description></item><item><title>golang--flag</title><link>https://reggieteng.github.io/posts/2021/04/golang-flag/</link><pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/04/golang-flag/</guid><description>简介 flag包是golang标准包之一.它实现了命令行参数的解析.flag包使得开发命令行工具更为简单.
基本流程 使用flag包基本流程分为三步
1 定义需要解析的命令行参数 2 调用flag.Parse() 3 根据后续的逻辑处理解析后的flag参数 1.定义命令行参数 // option 1 // string的注册,其中&amp;#34;l&amp;#34;为调用时的name &amp;#34;warn&amp;#34;为默认值 &amp;#34;log level&amp;#34;可理解为说明 FlagLogLevel = flag.String(&amp;#34;l&amp;#34;, &amp;#34;warn&amp;#34;, &amp;#34;log level&amp;#34;) // int的注册 FlagThreads = flag.Int(&amp;#34;t&amp;#34;, 3, &amp;#34;threads used when starting&amp;#34;) // bool的注册 FlagVersion = flag.Bool(&amp;#34;v&amp;#34;, false, &amp;#34;show version&amp;#34;) // option 2 // flag.XxxVar()，将 flag 绑定到一个变量上 var flagLogLevel string var flagThreads int var flagVersion bool flag.StringVar(&amp;amp;flagLogLevel, &amp;#34;l&amp;#34;, &amp;#34;warn&amp;#34;, &amp;#34;log level&amp;#34;) flag.IntVar(&amp;amp;flagThreads, &amp;#34;t&amp;#34;, 1234, &amp;#34;threads used when starting&amp;#34;) flag.</description></item><item><title>gin分模块注册router</title><link>https://reggieteng.github.io/posts/2021/03/gin%E5%88%86%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%86%8Crouter/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/03/gin%E5%88%86%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%86%8Crouter/</guid><description>最基本的路由注册
下面是最基本的router注册方式,只适用于小型项目或学习demo
package main import ( &amp;#34;net/http&amp;#34; &amp;#34;github.com/gin-gonic/gin&amp;#34; ) func helloHandler(c *gin.Context) { c.JSON(http.StatusOK, gin.JSON{ &amp;#34;message&amp;#34;: &amp;#34;Hello world!&amp;#34;, }) } func main() { r := gin.Default() r.GET(&amp;#34;/hello&amp;#34;, helloHandler) if err := r.Run(); err != nil { fmt.Println(&amp;#34;launch service failed, err:%v\n&amp;#34;, err) } } router注册拆出
当项目的规模逐渐变大时,在main,go中定义router非常不合适.此时就可以考虑将router部分代码单独写出。此时文件结构为
. ├── ... --- 其他文件 ├── main.go --- 项目入口 └── router.go --- router文件 其中router.go代码如下
package main import ( &amp;#34;net/http&amp;#34; &amp;#34;github.com/gin-gonic/gin&amp;#34; ) func helloHandler(c *gin.</description></item><item><title>Debian添加work用户</title><link>https://reggieteng.github.io/posts/2021/03/debian%E6%B7%BB%E5%8A%A0work%E7%94%A8%E6%88%B7/</link><pubDate>Thu, 11 Mar 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/03/debian%E6%B7%BB%E5%8A%A0work%E7%94%A8%E6%88%B7/</guid><description>一般在开发中很少使用root用户，可以创建work用户进行软件安装等操作。
以root用户登陆服务器后，添加work用户 useradd -d /home/work -s /bin/bash -m work
设置work用户的密码 passwd work
将work用户添加至sudo组中 adduser work sudo
注意:以上操作均在root用户下操作，若非root用户，则需要加sudo
关于useradd命令的参数意义如下，供参考：
-c&amp;lt;备注&amp;gt;：加上备注文字。备注文字会保存在passwd的备注栏位中；
-d&amp;lt;登入目录&amp;gt;：指定用户登入时的启始目录； -D：变更预设值；
-e&amp;lt;有效期限&amp;gt;：指定帐号的有效期限；
-f&amp;lt;缓冲天数&amp;gt;：指定在密码过期后多少天即关闭该帐号；
-g&amp;lt;群组&amp;gt;：指定用户所属的群组；
-G&amp;lt;群组&amp;gt;：指定用户所属的附加群组；
-m：自动建立用户的登入目录；
-M：不要自动建立用户的登入目录；
-n：取消建立以用户名称为名的群组；
-r：建立系统帐号；
-s：指定用户登入后所使用的shell；
-u：指定用户id。</description></item></channel></rss>