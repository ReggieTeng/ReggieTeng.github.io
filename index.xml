<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hello</title><link>https://reggieteng.github.io/</link><description>Recent content on Hello</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Thu, 11 Nov 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://reggieteng.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>mongndb配置文件</title><link>https://reggieteng.github.io/posts/2021/11/mongndb%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link><pubDate>Thu, 11 Nov 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/11/mongndb%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid><description>mongodb的配置文件是mongod.conf，文件路径一般为/etc/mongod.conf下面就是一个配置文件的例子
# mongod.conf# file path:/etc/mongod.conf# for documentation of all options, see:# http://docs.mongodb.org/manual/reference/configuration-options/# Where and how to store data.storage:dbPath:/var/lib/mongodbjournal:enabled:true# engine:# wiredTiger:# where to write logging data.systemLog:destination:filelogAppend:truepath:/var/log/mongodb/mongod.log# network interfacesnet:port:27017bindIp:127.0.0.1# how the process runsprocessManagement:timeZoneInfo:/usr/share/zoneinfo#security:#operationProfiling:#replication:#sharding:## Enterprise-Only Options:#auditLog:#snmp:配置文件由以下几部分组成
systemLog processManagement cloud net security setParameter storage operationProfiling replication sharding auditLog snmp systemLog systemLog:verbosity:&amp;lt;int&amp;gt; default:0quiet:&amp;lt;boolean&amp;gt; default:falsetraceAllExceptions:&amp;lt;boolean&amp;gt; default:falsesyslogFacility:&amp;lt;string&amp;gt;path:&amp;lt;string&amp;gt;logAppend:&amp;lt;boolean&amp;gt; default:falselogRotate:&amp;lt;string&amp;gt; default:renamedestination:&amp;lt;string&amp;gt;timeStampFormat:&amp;lt;string&amp;gt;component:accessControl:verbosity:&amp;lt;int&amp;gt;command:verbosity:&amp;lt;int&amp;gt;# COMMENT additional component verbosity settings omitted for brevitysystemLog.verbosity 组件的默认日志消息详细级别。详细级别决定了 MongoDB 输出的信息和调试消息的数量
取值范围：0-5
systemLog.quiet 在尝试限制输出量的安静模式下运行 mongos 或 mongod</description></item><item><title>etcd的配置文件</title><link>https://reggieteng.github.io/posts/2021/10/etcd%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link><pubDate>Mon, 11 Oct 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/10/etcd%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid><description>etcd 是一种高度一致的分布式键值存储，它提供了一种可靠的方式来存储需要由分布式系统或机器集群访问的数据. 它有以下基本的功能
通过http请求读取和写入值 将数据存储在分层组织的目录中，就像在标准文件系统中一样 观察特定键或目录的变化并对值的变化做出反应 今天我们就来了解一下etcd配置文件
# This is the configuration file for the etcd server.# 节点名称 这个值和--initial-cluster flag (e.g., default=http://localhost:2380)中的key值一一对应，如果在集群环境中，name必须是唯一的，建议用主机名称或者机器IDname:&amp;#39;default&amp;#39;# 数据的存储路径data-dir:# 存放预写式日志,最大的作用是记录了整个数据变化的全部历程。未设置，共用--data-dir文件所在目录。可以配置路径为专用磁盘，有助于避免日志记录和其他io操作之间的io竞争wal-dir:# 数据快照触发数量，etcd处理指定的次数的事务提交后，生成数据快照snapshot-count:10000# 客户端连接后的心跳间隔（毫秒）heartbeat-interval:100# 集群选举的超时时间election-timeout:1000# Raise alarms when backend size exceeds the given quota. 0 means use the# default quota.quota-backend-bytes:0# 本节点与其他节点进行数据交换(选举，数据同步)的监听地址，地址写法是 scheme://IP:port，可以多个并用逗号隔开，如果配置是http://0.0.0.0:2380,将不限制node访问地址listen-peer-urls:http://localhost:2380# 监听地址，地址写法是 scheme://IP:port，可以多个并用逗号隔开，如果配置是http://0.0.0.0:2379,将不限制node访问地址listen-client-urls:http://localhost:2379# 要保留的快照文件的最大数量，0是无限制。Windows用户的默认值是无限制的，建议设置5以下的值。max-snapshots:5# 要保留的wal文件的最大数量，0是无限制。Windows用户的默认值是无限制的，建议设置5以下的值。max-wals:5# 逗号分隔的 CORS（跨源资源共享）来源白名单cors:# 通知其他节点与本节点进行数据交换（选举，同步）的地址，URL可以使用domain地址。与--listener-peer-urls不同在于listener-peer-urls用于请求客户端的接入控制，initial-advertise-peer-urls是告知其他集群节点访问哪个URL，一般来说，initial-advertise-peer-urlsl将是istener-peer-urls的子集initial-advertise-peer-urls:http://localhost:2380# 用于通知其他ETCD节点，客户端接入本节点的监听地址，一般来说advertise-client-urls是listen-client-urls子集，这些URL可以包含域名advertise-client-urls:http://localhost:2379# 集群发现服务地址discovery:# 发现服务失败时的预期行为（“exit”或“proxy”）。“proxy”仅支持v2 APIdiscovery-fallback:&amp;#39;proxy&amp;#39;# 用于流量到发现服务的HTTP代理discovery-proxy:# 用于引导集群的DNS sry域discovery-srv:# 用于引导初始集群配置，集群中所有节点的信息。initial-cluster:# 集群唯一标识，相同标识的节点将视为在一个集群内initial-cluster-token:&amp;#39;etcd-cluster&amp;#39;# 初始集群状态，设置new为初始静态或DNS引导期间出现的所有成员。如果将此选项设置为existing，则etcd将尝试加入现有群集。initial-cluster-state:&amp;#39;new&amp;#39;# 拒绝可能导致仲裁丢失的重新配置请求strict-reconfig-check:false# 接受etcd V2客户端请求enable-v2:true# 通过HTTP服务器启用运行时分析数据。地址位于客户端URL +“/ debug / pprof /”enable-pprof:true# 代理模式设置，（&amp;#34;off&amp;#34;, &amp;#34;readonly&amp;#34; or &amp;#34;on&amp;#34;）proxy:&amp;#39;off&amp;#39;# 在重新考虑代理请求之前，endpoints 将处于失败状态的时间（以毫秒为单位）proxy-failure-wait:5000# endpoints 刷新间隔的时间（以毫秒为单位）proxy-refresh-interval:30000# 拨号超时的时间（以毫秒为单位）或0表示禁用超时proxy-dial-timeout:1000# 写入超时的时间（以毫秒为单位）或0以禁用超时proxy-write-timeout:5000# 读取超时的时间（以毫秒为单位）或0以禁用超时。如果使用watch，不要改变这个值，因为使用长轮询请求proxy-read-timeout:0client-transport-security:# 客户端服务器TLS证书文件的路径。cert-file:# 客户端服务器TLS密钥文件的路径key-file:# 启用客户端证书验证。client-cert-auth:false# 客户端服务器的路径TLS可信CA证书文件trusted-ca-file:# 客户端TLS使用生成的证书auto-tls:falsepeer-transport-security:# Path to the peer server TLS cert file.</description></item><item><title>drone的yml文件详解</title><link>https://reggieteng.github.io/posts/2021/08/drone%E7%9A%84yml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</link><pubDate>Tue, 31 Aug 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/08/drone%E7%9A%84yml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</guid><description>cicd简介 CI全称为Continuous Integration，意为持续集成，是在源代码变更后自动检测、拉取、构建和进行自动化测试的过程，属于开发人员的自动化流程。该解决方案可以解决在一次开发中有太多应用分支，从而导致相互冲突的问题。其基本思路是，自动化监测代码仓库的变化并拉取最新代码、编译构建和自动化测试。CI的触发方式可分为以下三种：
轮询：按一定的时间间隔反复询问代码仓库是否发生了变更，若发生了变更则开启CI流程 定时：定期从代码仓库拉去最新代码并进行构建与测试，不必关心是否有变更发生 推送：当代码仓库发生变更时，通过推送的方式(如webhook)通知CI进行任务，这需要CI环境被代码仓库访问到，因此需要一个外网可达地址 CD指的是持续交付(Continuous Delivery)或持续部署(Continuous Deployment)。持续交付通常是指开发人员对应用的更改会自动进行错误测试并上传到存储库（如 GitHub 或容器注册表），然后由运维团队将其部署到实时生产环境中。持续部署指的是自动将开发人员的更改从存储库发布到生产环境，它以持续交付为基础，实现了管道后续阶段的自动化。 CI/CD 既可能仅指持续集成和持续交付构成的关联环节，也可以指持续集成、持续交付和持续部署这三项构成的关联环节。
Drone 基于Docker的 CI/CD 工具Drone所有编译、测试的流程都在Docker容器中进行。 开发者只需在项目中包含.drone.yml文件，将代码推送到git仓库，Drone就能够自动化的进行编译、测试、发布。 示例yml文件如下：
---kind:pipelinetype:dockername:default# 指定代码空间，git代码会被clone到指定的pathworkspace:path:/drone/src# 指定编译平台platform:os:linuxarch:amd64clone:disable:truevolumes:- name:godepspath:/go/pkgsteps:- name:测试环境代码clone# 失败退出failure:alwaysimage:golang:1.15commands:- git init- git fetch http://xxx.git dev- git checkout FETCH_HEAD- git rev-parse HEADwhen:branch:- devevent:- push- name:线上环境代码clonefailure:alwaysimage:golang:1.15commands:- git init- git fetch http://xxx.git dev --tags- git checkout FETCH_HEAD- git describe --abbrev=0- git describe --abbrev=0 &amp;gt; .tagswhen:event:- tag- name:代码静态检查# 忽略失败继续buildfailure:ignoreimage:golang:1.15pull:if-not-exists # 默认always，指定if-not-exists或never可以大幅度提高速度environment:GOPROXY:&amp;#34;https://goproxy.cn,direct&amp;#34;commands:- go get github.com/golangci/golangci-lint/cmd/golangci-lint@v1.41.1- golangci-lint run --fast- name:编译打包image:golang:1.</description></item><item><title>nginx配置文件</title><link>https://reggieteng.github.io/posts/2021/08/nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link><pubDate>Tue, 03 Aug 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/08/nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid><description>nginx的主配置文件是nginx.conf，这个配置文件一共由三部分组成，分别为全局块、events块和http块。在http块中，又包含http全局块、多个server块。每个server块中，可以包含server全局块和多个location块。在同一配置块中嵌套的配置块，各个之间不存在次序关系。下面就是一个nginx.conf
#全局块 #user nobody; worker_processes 1; #event块 events { worker_connections 1024; } #http块 http { #http全局块 include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; #server块 server { #server全局块 listen 8000; server_name localhost; #location块 location / { root html; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } #这边可以有多个server块 server { ... } } 一、全局块 主要设置一些影响Nginx服务器整体运行的配置指令，因此，这些指令的作用域是Nginx服务器全局。
# 指定可以运行nginx服务的用户和用户组，只能在全局块配置 # user [user] [group] # 将user指令注释掉，或者配置成nobody的话所有用户都可以运行 # user nobody nobody; # 指定工作线程数，可以制定具体的进程数，也可使用自动模式，这个指令只能在全局块配置 # worker_processes number | auto； # 举例：指定4个工作线程，这种情况下会生成一个master进程和4个worker进程 # worker_processes 4; 二、events块 events块涉及的指令主要影响Nginx服务器与用户的网络连接。常用到的设置包括是否开启对多worker process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型处理连接请求，每个worker process可以同时支持的最大连接数等。</description></item><item><title>sqlx--golang操作数据库的第三方包</title><link>https://reggieteng.github.io/posts/2021/05/sqlx-golang%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85/</link><pubDate>Fri, 14 May 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/05/sqlx-golang%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85/</guid><description>一、简介
sqlx是一个操作数据库的库,它在golang标准包database/sql之上增加了很多扩展，简化数据库操作代码的书写.配合sql driver可支持mysql、postgresql.
sqlx设计和database/sql使用方法是一样的.包含有4中主要的handle types:
sqlx.DB - 和sql.DB相似，表示数据库. sqlx.Tx - 和sql.Tx相似，表示transacion。 sqlx.Stmt - 和sql.Stmt相似，表示prepared statement. sqlx.NamedStmt - 表示prepared statement（支持named parameters） 所有的handler types都提供了对database/sql的兼容，意味着当你调用sql.DB.Query时,可以直接替换为sqlx.DB.Query.这就使得sqlx可以很容易的加入到已有的数据库项目中.
此外，sqlx还有两个cursor类型:
sqlx.Rows - 和sql.Rows类似，Queryx返回. sqlx.Row - 和sql.Row类似，QueryRowx返回. 二、使用
1.获取DB对象(sqlx.Open())
// Open is the same as sql.Open, but returns an *sqlx.DB instead. func Open(driverName, dataSourceName string) (*DB, error) { db, err := sql.Open(driverName, dataSourceName) if err != nil { return nil, err } return &amp;amp;DB{DB: db, driverName: driverName, Mapper: mapper()}, err } sqlx.</description></item><item><title>golang--strconv</title><link>https://reggieteng.github.io/posts/2021/04/golang-strconv/</link><pubDate>Tue, 20 Apr 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/04/golang-strconv/</guid><description>简介 strconv包实现了基本数据类型和其字符串表示的相互转换，常用于string转int
字符串转换为整型之间的转换 字符串转换为整型 包括三个函数：ParseInt()、ParseUint() 和 Atoi().其中Atoi()是ParseInt()的便捷版，内部通过调用ParseInt(s, 10, 0)来实现的; ParseInt 转为有符号整型；ParseUint 转为无符号整型，
// 参数 s 代表待转换的字符串 // 参数 base 代表字符串按照给定的进制进行解释 // 参数 bitSize 表示的是整数取值范围,或者说整数的具体类型。取值 0、8、16、32 和 64 分别代表 int、int8、int16、int32 和 int64。 func ParseInt(s string, base int, bitSize int) (i int64, err error) func ParseUint(s string, base int, bitSize int) (n uint64, err error) func Atoi(s string) (i int, err error) n, err := strconv.ParseInt(&amp;#34;128&amp;#34;, 10, 8) 注意:
如上转换ParseInt/ParseUint实现时,如果字符串表示的整数超过了bitSize参数能够表示的范围,则会返回ErrRange,同时会返回bitSize能够表示的最大或最小值.因此,这里的n是 127. ParseInt()返回的是int64,这是为了能够容纳所有的整型,在实际使用中,可以根据传递的 bitSize,然后将结果转为实际需要的类型.</description></item><item><title>golang/x包--ssh</title><link>https://reggieteng.github.io/posts/2021/04/golang/x%E5%8C%85-ssh/</link><pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/04/golang/x%E5%8C%85-ssh/</guid><description>简介 在相对较小的项目中我们的服务器很少，此时我们会直接使用ssh登录服务器对服务器进行管理。当服务器增多/服务器更换后，对服务器的管理就会变得很麻烦和低效。此时我们必须要实现服务器管理的自动化。
远程命令执行 golang.org/x/crypto/ssh包就是golang中对ssh协议的实现。 我们分四步进行:
创建ssh登陆配置(ssh.ClientConfig) dial 获取ssh client 创建ssh-session 执行远程命令 1.创建ssh.ClientConfig 源码中ssh.ClientConfig 结构体如下
type ClientConfig struct { // Config contains configuration that is shared between clients and // servers. Config // User contains the username to authenticate as. User string // Auth contains possible authentication methods to use with the // server. Only the first instance of a particular RFC 4252 method will // be used during authentication.</description></item><item><title>golang--flag</title><link>https://reggieteng.github.io/posts/2021/04/golang-flag/</link><pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/04/golang-flag/</guid><description>简介 flag包是golang标准包之一.它实现了命令行参数的解析.flag包使得开发命令行工具更为简单.
基本流程 使用flag包基本流程分为三步
1 定义需要解析的命令行参数 2 调用flag.Parse() 3 根据后续的逻辑处理解析后的flag参数 1.定义命令行参数 // option 1 // string的注册,其中&amp;#34;l&amp;#34;为调用时的name &amp;#34;warn&amp;#34;为默认值 &amp;#34;log level&amp;#34;可理解为说明 var FlagLogLevel = flag.String(&amp;#34;l&amp;#34;, &amp;#34;warn&amp;#34;, &amp;#34;log level&amp;#34;) // int的注册 var FlagThreads = flag.Int(&amp;#34;t&amp;#34;, 3, &amp;#34;threads used when starting&amp;#34;) // bool的注册 var FlagVersion = flag.Bool(&amp;#34;v&amp;#34;, false, &amp;#34;show version&amp;#34;) // option 2 // flag.XxxVar()，将 flag 绑定到一个变量上 var flagLogLevel string var flagThreads int var flagVersion bool flag.StringVar(&amp;amp;flagLogLevel, &amp;#34;l&amp;#34;, &amp;#34;warn&amp;#34;, &amp;#34;log level&amp;#34;) flag.IntVar(&amp;amp;flagThreads, &amp;#34;t&amp;#34;, 1234, &amp;#34;threads used when starting&amp;#34;) flag.</description></item><item><title>gin分模块注册router</title><link>https://reggieteng.github.io/posts/2021/03/gin%E5%88%86%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%86%8Crouter/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/03/gin%E5%88%86%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%86%8Crouter/</guid><description>最基本的路由注册
下面是最基本的router注册方式,只适用于小型项目或学习demo
package main import ( &amp;#34;net/http&amp;#34; &amp;#34;github.com/gin-gonic/gin&amp;#34; ) func helloHandler(c *gin.Context) { c.JSON(http.StatusOK, gin.JSON{ &amp;#34;message&amp;#34;: &amp;#34;Hello world!&amp;#34;, }) } func main() { r := gin.Default() r.GET(&amp;#34;/hello&amp;#34;, helloHandler) if err := r.Run(); err != nil { fmt.Println(&amp;#34;launch service failed, err:%v\n&amp;#34;, err) } } router注册拆出
当项目的规模逐渐变大时,在main,go中定义router非常不合适.此时就可以考虑将router部分代码单独写出。此时文件结构为
. ├── ... --- 其他文件 ├── main.go --- 项目入口 └── router.go --- router文件 其中router.go代码如下
package main import ( &amp;#34;net/http&amp;#34; &amp;#34;github.com/gin-gonic/gin&amp;#34; ) func helloHandler(c *gin.</description></item><item><title>Debian添加work用户</title><link>https://reggieteng.github.io/posts/2021/03/debian%E6%B7%BB%E5%8A%A0work%E7%94%A8%E6%88%B7/</link><pubDate>Thu, 11 Mar 2021 00:00:00 +0000</pubDate><guid>https://reggieteng.github.io/posts/2021/03/debian%E6%B7%BB%E5%8A%A0work%E7%94%A8%E6%88%B7/</guid><description>一般在开发中很少使用root用户，可以创建work用户进行操作。
以root用户登陆服务器后，添加work用户 useradd -d /home/work -s /bin/bash -m work
设置work用户的密码 passwd work
注意:以上操作均在root用户下操作，若非root用户，则需要加sudo
关于useradd命令的参数意义如下，供参考：
-c&amp;lt;备注&amp;gt;：加上备注文字。备注文字会保存在passwd的备注栏位中；
-d&amp;lt;登入目录&amp;gt;：指定用户登入时的启始目录； -D：变更预设值；
-e&amp;lt;有效期限&amp;gt;：指定帐号的有效期限；
-f&amp;lt;缓冲天数&amp;gt;：指定在密码过期后多少天即关闭该帐号；
-g&amp;lt;群组&amp;gt;：指定用户所属的群组；
-G&amp;lt;群组&amp;gt;：指定用户所属的附加群组；
-m：自动建立用户的登入目录；
-M：不要自动建立用户的登入目录；
-n：取消建立以用户名称为名的群组；
-r：建立系统帐号；
-s：指定用户登入后所使用的shell；
-u：指定用户id。</description></item></channel></rss>